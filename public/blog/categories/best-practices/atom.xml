<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Best Practices | The Technician]]></title>
  <link href="http://chr.ishenry.com/blog/categories/best-practices/atom.xml" rel="self"/>
  <link href="http://chr.ishenry.com/"/>
  <updated>2013-09-03T22:54:01-04:00</updated>
  <id>http://chr.ishenry.com/</id>
  <author>
    <name><![CDATA[Chris Henry]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[MySQL's INSERT SELECT, Replication, and You]]></title>
    <link href="http://chr.ishenry.com/2012/08/13/mysqls-insert-select-replication-and-you/"/>
    <updated>2012-08-13T00:00:00-04:00</updated>
    <id>http://chr.ishenry.com/2012/08/13/mysqls-insert-select-replication-and-you</id>
    <content type="html"><![CDATA[<p>Whenever there are situations where data needs to be copied from table to
table, or SELECTing lots of rows to be inserted, the <a href="http://dev.mysql.com/doc/refman/5.5/en/insert-select.html">INSERT
SELECT</a> is an
elegant solution. It reduces the number of queries sent to a MySQL server, and
makes for elegant code. Additionally, with INSERT SELECTs, all processing
happens on the MySQL side. The app doesn't have to deal with having any of the
data in memory. This means that application servers can be run with less
memory.</p>

<p>Unfortunately, INSERT SELECT's best use cases coincide with cases where the
SELECT query has the potential to run a long time. On standalone servers
running InnoDB, this can be fine, as reads and writes will continue to execute
concurrently. However, if you're running MyISAM, queries will lock, and
nothing will execute. Instead, queries will queue up, your application will
come to a dead halt, MySQL will likely hit max_connections and Very Bad Things
will happen.</p>

<p>In <a href="http://dev.mysql.com/doc/refman/5.5/en/replication-%0Aimplementation.html">replicated</a> environments, even well tuned ones running on InnoDB, a
long running INSERT SELECT can cause other sorts of problem. MySQL replication
is statement based. In other words, every statement that writes to disk on the
master is written to a log. The log is then transferred to slave(s), and those
statements are replayed on the slaves.</p>

<p>With INSERT SELECTS, every slave needs to run the same SELECT. The master will
not simply pass on the results of the SELECT, but rather simply pass the same
query to be executed by the slave(s). So in a replicated environment, it's
even more important to keep an eye on how long those INSERT SELECTS are
running. Not only is it a waste of processing power to run the SELECT portion
of the query across the entire cluster, the SELECT will actually block other
statements in the log from executing. This means that the data on the slaves
will become out of sync with the master, a condition called slave lag.</p>

<p>INSERT SELECT is a great tool, but beware of the costs of using it in certain
situations.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Workflow with Synergy]]></title>
    <link href="http://chr.ishenry.com/2012/05/26/workflow-with-synergy/"/>
    <updated>2012-05-26T00:00:00-04:00</updated>
    <id>http://chr.ishenry.com/2012/05/26/workflow-with-synergy</id>
    <content type="html"><![CDATA[<p>As a web developer working in lots of different areas, I have to use <a href="http://blog.behance.net/dev/developers-toolkit-chris-%0Ahenry">lots of
different programs</a> to perform various tasks. Terminal for SSH, Eclipse for php, etc.
Chrome for all things web browsing, including Gmail. Eventually, the number of
tabs I needed to keep open during the day caused my gmail tabs to get lost
pretty easily, even after using the pin feature. Then I stumbled upon
<a href="http://mailplaneapp.com/new_index">Mailplane</a>. Mailplane is a stellar program
that turns gmail into a desktop app.</p>

<p>After adding yet another app to my stable, it seemed necessary to divide my
screen real estate into spaces. Part of the problem of having so many
different programs is the problem of context. Once situating the necessary
programs in a way that makes sense for the particular task, changing context
can completely knock me out of my flow. For a period of time, it didn't even
make sense to use Mailplane, as it was easier to actually switch over to my
phone, and read / respond to email there.</p>

<p>Then it hit, why not just bring in my laptop, and deal with email there. So I
started bringing my laptop. This was awesome, as it allowed me to deal with
email on relatively normal sized screen and keyboard. The next issue was
dealing with links in emails. After asking the twitterverse and stackexchange,
I finally settled on <a href="http://synergy-foss.org/">Synergy</a>. Synergy allows you
to seamless share your keyboard and mouse between any number of machines. So I
started running Mailplane in fullscreen mode on a laptop situated next to my
desktop. To get to my email, I just mouse all the way to the left, and voila,
I can use a full keyboard / mouse with a laptop. If I need to open links on
the big screens, I just copy and use Chrome's paste &amp; go feature.</p>

<p>This works tremendously well, as I can leave any development task as is on my
desktop without having to worry about shuffling things around. It also helps
tremendously when applying pesky software updates, as you always have one
machine that will be up and running.</p>

<p><a href="/images/user/workflow_synergy.jpg"><img src="/images/user/workflow_synergy.jpg" alt="Rig at the Behnace Office" /></a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New Years Actionable (non-whiner) Resolutions]]></title>
    <link href="http://chr.ishenry.com/2012/01/03/new-years-actionable-non-whiner-resolutions/"/>
    <updated>2012-01-03T00:00:00-05:00</updated>
    <id>http://chr.ishenry.com/2012/01/03/new-years-actionable-non-whiner-resolutions</id>
    <content type="html"><![CDATA[<p>Normally, I've considered New Year's Resolutions to be for whiners, people who
never actually accomplish anything, people who are normally on the
whhhaaaambulance. Most resolutions fall somewhere in the "stop being fat" to
"be fluent in mesopotamian glyphs" range. They're vague, completely un-
actionable, and just describe a slightly unattainable goal / end result /
dumbass want. This year, however, I've discovered a few serious problems in my
life I need to fix. So, in the spirit of actually doing shit, I've provided a
list of non-whiner resolutions + ways to actually make them happen.</p>

<ol>
<li><p><strong>Go to bed early(ish)</strong>. This is a tough one for me. I'm naturally a night
owl, but I might be able to fool myself to getting to bed early by showering
early(ish). I love me a good shower. I've even been known to drink a beer in
the shower. I also really like being in really warm, comfortable, if slightly
embarrassing, PJs. All these things put me in a good mood and generally make
me want to relax, which is not all that far from being asleep. Action Steps:
Just get in the fucking shower, don't look at the mail / email / dirty dishes
/ messy apartment / email / Twitter, just get in the shower (bring a beer).</p></li>
<li><p><strong>See some doctors</strong>. I've avoided doctors for awhile, mostly because my
lifestyle is a cross between Denis Nedry from Jurassic Park and a barfly. I
consider this pretty simple. Action Steps: Make appointments with the
following: dentist, general physician, eye doctor, nutritionist. Do it. Do
what they say, even if it sucks. Follow up as often as the quacks say so.</p></li>
<li><p><strong>Go to the gym regularly</strong>. OK, this one is, without a doubt, the most
cliche, whine-tastic resolution evar. I know, because I have been to the gym
in January. I've also been to the gym in April, when all the kids who were at
the gym in January are nowhere to be found. Also, since the gym is a #creepy
and #gross place to shower, resolution #1 should be even more important.
Action Steps: Put that ish on the Google calendar with the following
reminders; 2 hours, 1 hour, 30 minutes, 15 minutes, 10 minutes, and 5 minutes
before. Keep gym clothes in the office. Don't care how bad they smell.</p></li>
<li><p><strong>Blog more</strong>. Writing has been a great way to get me to collect my
thoughts, find some hindsight, and maybe, just maybe, help some other folks
who have the same demented thoughts / stupid problems. As a technical guy,
"the inspiration" doesn't hit me so often, and when it does, I'm often busy,
y'know, actually doing shit. However, as I've noted to myself more than once,
keeping track of my day and journaling how I spend my time is something
incredibly important for introspection. Action Steps: Write that thought down.
Write down what you did 30 seconds ago, especially if it was different from
regularly scheduled programming. Keep a sticky on your monitor to write shite
down. Ask the dude next to you (<a href="http://twitter.com/bossjones">@bossjones</a>) to
remind you to you write shit down. Lastly, a glass (or 7) of white wine, the
notebook in which all your shit is written, and wordpress should convene
regularly. Google Calendar #ftw, again. Lastly, check Google Analytics on
posts. The un-monitored blog post is not worth writing.</p></li>
<li><p><strong>Read more</strong>. Once upon a time (yesterday) I didn't know nearly as much as
I do now. Most of that knowledge came from reading shit-tons of blogs, books,
bathroom graffiti, articles, and whitepapers related to web development. I
read everything with a goal: How can I use, or leverage this to help me / my
business work a little better? The Action Steps here are a bit tougher, and
slightly conflict with non-whiner resolution #6: Keep Google Reader open.
Curate my list of feeds with relevant sources. Prune feeds that stopped
providing useful information. Lastly, and perhaps most important, find tidbits
of information that make a difference in my life and / or business.</p></li>
<li><p><strong>Don't be distracted by bold numbers in parentheses</strong>. Simple (kinda).
Action Steps: close Gmail, close Twitter. Try, and #fail, to delete my
Facebook account.</p></li>
<li><p><strong>Stop playing so much fucking air guitar by myself, alone in my apt, and
start playing some real guitar, and actually learn the songs I normally rock
out to</strong>. Action Steps: restring the Epiphone, buy a new amp, find tabs for
shit I want to learn. If I'm feeling really frisky, get back into a band.</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distributed Updates]]></title>
    <link href="http://chr.ishenry.com/2011/06/25/distributed-updates/"/>
    <updated>2011-06-25T00:00:00-04:00</updated>
    <id>http://chr.ishenry.com/2011/06/25/distributed-updates</id>
    <content type="html"><![CDATA[<p>Part of managing any large site involves writing scripts that will go through
oyur data, make changes, merge things, remove things, do type transformations,
etc. Most of the time, in PHP, iterating through rows or objects will do just
fine. However, when there are lots of rows or objects, you could be faced with
a script that takes hours or days to run. Depending on how often active the
is, you may need to restrict access to ensure that the data before and after
the transformation remains consistent. In other words, if someone tries to
make a change to the data before the transformation, and the new feature only
looks at data after the transformation, that user has just lost their changes.
That is Very Bad.</p>

<p>As sites get larger and problems like this loom, taking the site offline
becomes less and less of an option. This is what the business team calls a
luxury problem, and what the ops team refers to simply as a problem. One
option is to write a more efficient script. You can get pretty far by simply
ensuring you're reading from the fastest data source available, make good use
of cache, etc. ensure that the tables being read for the transformation are
properly indexed. All of these are great places to start. Additionally, making
sure that data is grabbed in chunks can give the database time to breathe.
There's nothing worse than getting stuck in MySQL's "sending data" phase
simply because it needs to read several thousand rows from disk. MySQL
configuration can also be your friend here. If using InnoDB, increasing the
insert buffer is a great way to speed up writes.*</p>

<p>However, as much as you can do to speed up a single transaction, the fact
remains that you have to execute each transformation serially, one after
another. Your bottleneck is the transformation itself. It will take (# of
transformations * # of objects to transform) to complete the job. No matter
how well tuned the database is, it will only be performing one operation at a
time, which means that the other (max connections - 1) connections are doing
precisely crap. So the next logical step is to change your update script to
distribute the update operations so a few can be run in parrallel.</p>

<p>Rewriting the update script does require thinking about your update
differently, and will not work in every case. For example, if one is simply
moving a large amount of data from one table to another, and there is no
transformation, or the transformation can be accomplished via a builtin MySQL
function, use that. However, just be prepared to deal with locking issues, and
the source data potentially not being available while the transformation is
taking place. However, if your transformation is complicated, and requires
per-case logic, this is definitely a good route to take. The biggest
difference is how the code for the update is organized. The update script
needs to be separated out into code that will apply the transformation for
exactly one entity, and code that will manage which entities get transformed
and when. Ideally, the code for the transformation is idempotent, so failures
can be handled by simply resubmitting the entity / object to be transformed
again.</p>

<p>Accomplishing parallel processing in PHP can be kind of tricky. Php's
pcntl_exec function has always felt a bit finicky to me. Of course exec on its
own it blocking, so that's out. Additionally, neither of these solutions offer
any sort of baked-in communication between the process that submitted the job,
and the process carrying out the job. That leaves us with a queuing system.
Popular systems include: RabbitMQ and Gearman. Personally, I've made great use
of <a href="http://chr.ishenry.com/2009/07/25/gearman/">Gearman</a>. It's easy to
install, as is the PHP module.</p>

<p>To sum up, performing large data updates via a distributed system is the way
to go if you have complex requirements per transformation, and the option to
perform these processes in parallel.</p>

<p>*If using MySQL's MyISAM engine, this isn't necessarily true, as writes will block, and the database could become the bottleneck. However, since MySQL is continuing to push InnnDB, this is getting increasingly unlikely. So if your tables are all InnoDB, you're probably in good shape.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Progress Bar Pysch]]></title>
    <link href="http://chr.ishenry.com/2011/03/12/the-progress-bar-pysch/"/>
    <updated>2011-03-12T00:00:00-05:00</updated>
    <id>http://chr.ishenry.com/2011/03/12/the-progress-bar-pysch</id>
    <content type="html"><![CDATA[<p>A classic UX problems is communicating to users how long they'll have to wait
before their task completes. A spinner or progress bar provides feedback that
the system is, in fact, doing something, and how long that task may take.
Psychologically, progress bars create tension while progressing, and
resolution when completed.</p>

<p>From a technical standpoint, progress bars are black magic. The developer is
attempting to estimate a task based on potentially thousands of variables. In
the case of a file upload, the developer has to deal with differing network
conditions, disk performance, etc, etc, etc. Then they have to write the code
to communicate what is happening to the browser. Not a trivial task. However,
when executed well, can provide the user with reasonable feedback about their
task.</p>

<p>Lately, sites like LinkedIn, Mint.com, and OKCupid have used that same tension
to motivate users to completely fill out their profiles. During profile
creation, a progress bar is displayed indicating how far the user has come
along. Once the user completely fills out their profile, the progress bar hits
100%, and what changes? In most cases, nothing. The progress bar is just a
psychological hack to entice users to go through the entire process.</p>

<p>The question is: Exactly how effective is the progress bar at enticing users
to fully complete the task at hand? And are they actually worth it.</p>
]]></content>
  </entry>
  
</feed>
