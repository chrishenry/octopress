<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Development | The Technician]]></title>
  <link href="http://chr.ishenry.com/blog/categories/development/atom.xml" rel="self"/>
  <link href="http://chr.ishenry.com/"/>
  <updated>2015-06-27T15:12:16-04:00</updated>
  <id>http://chr.ishenry.com/</id>
  <author>
    <name><![CDATA[Chris Henry]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[FizzBuzz-a-thon]]></title>
    <link href="http://chr.ishenry.com/2012/12/10/fizzbuzz-a-thon/"/>
    <updated>2012-12-10T00:00:00-05:00</updated>
    <id>http://chr.ishenry.com/2012/12/10/fizzbuzz-a-thon</id>
    <content type="html"><![CDATA[<p>The <a href="http://www.codinghorror.com/blog/2007/02/why-cant-programmers-%0Aprogram.html">FizzBuzz</a> test is a simple way of showing that a developer has mastery of
basic concepts like loops, variables and operators. Having given the test to
other developers several times, I felt like a bit of hypocrite having never
actually having taken it myself. I've also asked folks to complete the task in
php, even though it wasn't a language they were particularly familiar with.
So, I decided it was time to end the hypocrisy, and give myself a little
challenge:</p>

<p><strong>Do FizzBuzz in as many languages as I could.</strong></p>

<p>So, what did I learn?</p>

<ul>
<li>With the <a href="http://chr.ishenry.com/2011/06/13/development-without-internet-access/">internet</a>, you can learn the basics of most programming languages in about 5 minutes.</li>
<li>Programming knowledge is portable between most common web languages. A loop is a loop, a variable is a variable, etc. Syntax for a task this simple can be learned in a few minutes.</li>
<li>FizzBuzz <em>can</em> be done in sql, bitch.</li>
<li>Clojure is hard for no reason.</li>
<li>Lisp is basically impossible to get running.</li>
<li>Languages have uptake because they're included with the OS and have good documentation and communities.
In the end, doing FizzBuzz in 10 languages took around 5 hours. There was,
however, significant time taken for screwing around on Twitter, potty breaks,
drinking too much coffee, <a href="http://stackoverflow.com/questions/13536889/php-works-but-%0Agives-sql-syntax-error/13536929#comment18536820_13536929">curmedgeon-ing on
StackOverflow,</a> drinking beer, and
making carnitas. Time was also spent looking for a way to run my FizzBuzzes in
bash and benchmark them, which proved fruitless, since OS X doesn't support
nanoseconds in the date command.</li>
</ul>


<p>For a closer look at the code, take a look at the <a href="https://github.com/chrishenry/fizzbuzz">github
repo.</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Argument for Generalists in Web Development]]></title>
    <link href="http://chr.ishenry.com/2012/07/09/the-argument-for-generalists-in-web-development/"/>
    <updated>2012-07-09T00:00:00-04:00</updated>
    <id>http://chr.ishenry.com/2012/07/09/the-argument-for-generalists-in-web-development</id>
    <content type="html"><![CDATA[<p>"An expert is one who knows more and more about less and less until he knows
absolutely everything about nothing"
-<a href="https://twitter.com/mastersje/status/192257585745891330">@mastersje</a></p>

<p>My grandfather was a carpenter. He had an immense workbench, with a pegboard
that had hundreds of hammers, screwdrivers, wrenches, saws, drills, planes,
awls. They were powered, hand powered, circular, rotary and reciprocating.
Each of them had their own beauty, and their own use. The man could build a
picture frame, a desk, a dock, or an entire house. He may not have wielded any
of them expertly, but he knew which one to use when the situation called, and
he certainly knew how to use them in concert.</p>

<p>Two generations later, I have become a web developer, and can't help but
notice the similarities between the two. He worked in wood, but I work in bits
and bytes. Web sites, especially big ones, are not the product of a single
technology, but the result of many technologies seamlessly interacting.
Building a house is no different. Framing, roofing, laying foundation are all
separate skills that require vastly different tools. Part of the challenge of
being a web developer is being able to manage lots of technologies at once.</p>

<p>Great web developers are carpenters. Just like carpentry, there is always the
right tool for the job. Infrastructure that doesn't play well with software is
bound for failure. Software that doesn't use or fit the hardware / kernel / OS
well won't run well. As experts in web development, we can know less about
each technology, but should know more about how they work together. Tailoring
software or combinations of software packages is the magic bullet that solves
problems quickly and scalably.</p>

<p>In the context of early stage startups, generalists are a better bet for
getting a production up and running. Even as a team grows, having generalists
around means you can task a single developer with developing and entire
feature. With a bit of support from specialists, they can pull off shipping a
feature faster than a team of a couple of specialists. When widespread  issues
occur, I prefer to have a generalist in my corner, because they typically
understand the the connective tissue of a website very well, and are willing
to put in the time debugging from a variety of perspectives.</p>

<p>None of this is to say that specialists don't have their place in web
development. The web is an innovative medium that it has spawned dozens of
technologies (node.js) that require a deep pool of expertise to work in. There
are vast arrays of techniques and frameworks that cater to working in a single
technology. Generalists typically won't have the depth necessary to pull off a
awe-inspiring, truly nasty implementation. However, they'll have the right
instincts to pair it, deploy, and make it do something meaningful that a
specialist might not be able to do by themselves.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Development without Internet Access]]></title>
    <link href="http://chr.ishenry.com/2011/06/12/development-without-internet-access/"/>
    <updated>2011-06-12T00:00:00-04:00</updated>
    <id>http://chr.ishenry.com/2011/06/12/development-without-internet-access</id>
    <content type="html"><![CDATA[<p>While flying to Austin for sxsw, I had a small programming task. Take a string
of a few search terms, break it apart and highlight those terms in another
string. It's a straightforward task, and probably a wheel that's been
reinvented thousands of time in the history of computer science. I approached
it as an exercise, to see if I could add another squeaky wheel to the pile. My
goal was to do it without using any 3rd party code or any resources. I had no
access to documentation, google, stack overflow, or any of the other resources
I use constantly to get my job done every day.</p>

<p>The code that I produced was bloated, naive, and horribly inefficient (I
suspect). While writing it, i knew I wasn't really on the right path. When I
got back to New York, I took a look at it, and more or less decided I had
wasted my time. Then I realized I had written it on a plane, and had nothing
better to do. I simply got myself into the zone, and wanted to work through a
problem until it was solved. After I got over my initial disgust, I wondered
what aside from boredom and stubbornness had prompted me to complete the task.</p>

<p>I never really came to any conclusions until a few days later. I was going
about my day normally, fixing bugs, writing emails, troubleshooting. As I hit
a hard spot, something I couldn't figure out, I gave up staring at the code,
and turned to Google. Then I came across a builtin php function that was
giving me a strange result. After puzzling for a few seconds, I dropped the
function into Google. A little while later, I was examining the results of an
EXPLAIN statement in MySQL, and the output was something I hadn't seen before.
I found the answer on StackOverflow a few minutes later.</p>

<p>Then it dawned on me. Maybe I don't actually have the skills to be a web
developer, and I've faked it all these years. Maybe I don't know all that much
about MySQL, and perhaps I only know enough about Linux to cause problems for
Rackspace. Whether or not that's true, I did realize that I'm pretty good at
finding solutions to problems from the collective experiences, wisdom, and
flames of the Internet. Maybe it's not entirely fair to say that I faked my
way through several years of a career. After all the code that I've put
together over the years to answer various questions, or sift through or
collect data serves a purpose, performs relatively well, and is serving people
everyday. Also, that disgusting snippet of string highlighting code works
pretty well, despite that fact that I hate its face and want it to die.</p>

<p>After I got myself out of my existential development funk, more questions came
to mind. First, how the F did anyone get any answers to tough questions before
the Internet? Secondly, how did programmers back in the day find any sort of
direction? Books on technology and programming are great, don't get me wrong,
but you can't get answers to complicated questions. After having these
thoughts crop up, I spent a little bit of time looking over other devs'
shoulders at the office. What I saw was very reassuring, as the Google machine
was often hard at work for the rest of the team. The php site, StackOverflow,
and QuirksMode were in browsers constantly.</p>

<p>Which begs yet another question: what exactly does it take to be a web
programmer? Based on my experience, it seems to boil down to an Internet
connection, Google, tenacity to the point of stupidity, and decent search
skills. To back up even further, is it possible to take on a job you know
nothing about, and learn how do it via the Internet?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sphinx Full Text Search Engine]]></title>
    <link href="http://chr.ishenry.com/2010/01/29/sphinx-full-text-search-engine/"/>
    <updated>2010-01-29T00:00:00-05:00</updated>
    <id>http://chr.ishenry.com/2010/01/29/sphinx-full-text-search-engine</id>
    <content type="html"><![CDATA[<p>For a very long time, I was convinced that a FULLTEXT index in MySQL was the
best solution for all your searching needs. Then I realized that it was
horribly slow, and mixing with complex joins completely destroyed any chances
of using MySQL indexes in any way that would make sense or get decent results.
The solution to fast and scalable free text search on any website is, of
course, a Full Text search engine.</p>

<p>There are a few different ones out there. After a brief affair with Lucene, I
settled on Sphinx. Sphinx is easy to install, even on 64-bit machines, and is
architected in a way that makes a lot of sense for the web. The following
steps were performed on a Red Hat machine. Don't skip the mysql-dev install,
even if you already MySQL installed.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>Sphinx installation  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>yum install gcc-c++
</span><span class='line'>yum install mysql-dev*
</span><span class='line'>wget http://www.sphinxsearch.com/downloads/sphinx-0.9.9.tar.gz
</span><span class='line'>tar xzvf sphinx-0.9.9.tar.gz
</span><span class='line'>mkdir /usr/local/sphinx
</span><span class='line'>./configure --prefix /usr/local/sphinx --with-mysql&gt; ./make
</span><span class='line'>make install
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Once installed, it's fairly simple to start playing with the packaged example
data and queries. The php APIs make integration easy, either to build a
service, or use locally as a substitute for MySQL. In fact, as long as the
index can be kept reasonably up to date, Sphinx is a better choice for
complicated sorts than MySQL.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's in a Name?]]></title>
    <link href="http://chr.ishenry.com/2009/10/14/whats-in-a-name/"/>
    <updated>2009-10-14T00:00:00-04:00</updated>
    <id>http://chr.ishenry.com/2009/10/14/whats-in-a-name</id>
    <content type="html"><![CDATA[<p>It's easy to get caught up in semantics. Figuring out the best names for
variables, tables, columns, classes, etc is something that can eat up hours or
even days of a development schedule. The idea is that the more precise the
name, the better it is. The arguments for precision naming are many :</p>

<ul>
<li>Clear names help other developers read your code.<em> New developers who come on will immediately understand what's happening</em> Calling well named methods of classes will read like sentence, further increasing readability.* Clear names will be able to help developers relate things in the UI to the code.</li>
</ul>


<p>Keep in mind, I'm not talking about <a href="http://en.wikipedia.org/wiki/Identifier_naming_convention">naming
conventions</a>.
Naming conventions are simply rules for choosing the character sequences. They
don't dictate what words you should assign to things in your code.</p>

<p>Whatever names developers choose, they will get strewn throughout the layers
of the application. Database, table and column names will be impacted.
Variables in server-side scripts. Organization of classes into folders.
Javascript file names. Memcache keys. URLs. Just like sand at the beach, the
labels the dev team decided on goes everywhere you can think of. Invariably,
the marketing team will bound down the hall, and announce the product is being
rebranded. Jobs will become Gigs. Friends will become Followers. Application
code will become confusing.</p>

<p>New devs won't get it anyway.</p>

<p>The fact of the matter is overthinking naming is a good way to get nowhere
fast. Keeping it simple and just take enough time to make sure that things
make sense will give devs more time to focus on important stuff. Like being
able to articulate the thought <a href="http://chr.ishenry.com/2009/07/01/explain-your-code/">process behind
code</a>.</p>
]]></content>
  </entry>
  
</feed>
