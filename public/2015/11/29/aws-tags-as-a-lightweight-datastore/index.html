
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>AWS Tags as a Lightweight Datastore - The Technician</title>
	<meta name="author" content="Chris Henry">

	
	<meta name="description" content="One of the most common tasks in administering clusters of machines is running
regular tasks on individual machines in a cluster. For example, &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="The Technician" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">The Technician</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/">Blog</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:chr.ishenry.com">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		<a class="twitter" href="http://twitter.com/chrishnry" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/chrishenry" title="GitHub">GitHub</a>
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
		
		<a class="feedly" title="Feedly" href="http://cloud.feedly.com/#subscription%2Ffeed%2Fhttp%3A%2F%2Fchr.ishenry.com%2Fatom.xml" target="blank">Feedly</a>
		
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:chr.ishenry.com">
	</form>
</nav>

</header>
	<div id="content" class="inner"><article class="post">
	<h2 class="title">AWS Tags as a Lightweight Datastore</h2>
	<div class="entry-content"><p>One of the most common tasks in administering clusters of machines is running
regular tasks on individual machines in a cluster. For example, Cassandra
benefits greatly from running repairs on individual nodes to ensure data
consistency. Operating manually, an ops team would maintain a document of when
each machine has been, and look at that to determine which machine should be
repaired next.</p>

<p>However, in a world where there could be hundreds of machines, this quickly
becomes unscalable. Even with only a handful of machines, a team could spend a
ton of energy and time simply remembering where the source of truth lives and
how to decide which machine should be repaired next.</p>

<!-- more -->


<p>A team could write some code to pick a node and run the necessary commands. This
is a bit better, but the requirement is that the command runs regularly on each
node in the cluster. Without a central record to track which nodes have been
repaired, there&#8217;s no way to know when and where the last repair was run, and no
way to accurately predict which node will be picked next.</p>

<p>Enter
<a href="http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/Using_Tags.html">AWS EC2 Tags</a>.
While EC2 tagging has some restrictions, it&#8217;s an ideal place to register small
bits of metadata and completely replace our old school document. For our
Cassandra example, it&#8217;s easy enough to use the EC2 APIs to list all machines in
an Autoscale Group, or by tag, and then apply some logic to pick a machine.</p>

<p>Here&#8217;s some sample code that will look at the instances in an ASG, and pick one
that either hasn&#8217;t been repaired, or the node repaired the longest time ago.</p>

<figure class='code'><figcaption><span>Find least recently repaired node </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="c">#!/usr/bin/env python</span>
</span><span class='line'>
</span><span class='line'><span class="kn">import</span> <span class="nn">boto.ec2</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">boto.ec2.autoscale</span>
</span><span class='line'>
</span><span class='line'><span class="n">ec2</span> <span class="o">=</span> <span class="n">boto</span><span class="o">.</span><span class="n">ec2</span><span class="o">.</span><span class="n">connect_to_region</span><span class="p">(</span><span class="s">&#39;us-east-1&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">asg</span> <span class="o">=</span> <span class="n">boto</span><span class="o">.</span><span class="n">ec2</span><span class="o">.</span><span class="n">autoscale</span><span class="o">.</span><span class="n">connect_to_region</span><span class="p">(</span><span class="s">&#39;us-east-1&#39;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">group</span> <span class="o">=</span> <span class="n">asg</span><span class="o">.</span><span class="n">get_all_groups</span><span class="p">(</span><span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s">&quot;your-asg&quot;</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'><span class="n">instance_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">instance_id</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">instances</span><span class="p">]</span>
</span><span class='line'><span class="n">instances</span> <span class="o">=</span> <span class="n">ec2</span><span class="o">.</span><span class="n">get_only_instances</span><span class="p">(</span><span class="n">instance_ids</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Find instances without a `last-repaired` tag</span>
</span><span class='line'><span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
</span><span class='line'>    <span class="k">if</span> <span class="s">&#39;last-repaired&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">instance</span><span class="o">.</span><span class="n">tags</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
</span><span class='line'>        <span class="k">print</span> <span class="s">&quot;Found an instance without last-repair tag&quot;</span>
</span><span class='line'>        <span class="k">print</span> <span class="n">instance</span>
</span><span class='line'>        <span class="nb">exit</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Sort instances by date asc, which is oldest first</span>
</span><span class='line'><span class="n">sorted_instances</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">instances</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">instance</span><span class="p">:</span> <span class="n">instance</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s">&#39;last-repaired&#39;</span><span class="p">])</span>
</span><span class='line'>
</span><span class='line'><span class="k">print</span> <span class="s">&quot;Found oldest repair: &quot;</span> <span class="o">+</span> <span class="n">sorted_instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">id</span>
</span><span class='line'><span class="k">print</span> <span class="n">sorted_instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="s">&#39;last-repaired&#39;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>The above snippet is based on the venerable
<a href="http://boto.readthedocs.org/en/latest/">boto</a> library. Using python for
interfacing with AWS allows you to use a mature, well-tested library. You can
even write tests against code that uses boto with a library of mocks called
<a href="https://github.com/spulec/moto">moto</a>. In short, it looks for instances that
haven&#8217;t been operated on first. This is to cover the situation where you have a
brand new cluster, or when the ASG group replaces nodes. Secondly, it sorts the
instances by the date of the last repair ascending, which gives you the oldest
node at the zeroth element of the list.</p>

<p>Taking this approach to managing infrastructure allows you create simple,
testable code with very few dependencies. Had <code>last-repair</code> data been stored in
a local database, it would require the team to create and maintain that
database, as well as write and test additional code. The team is now free to
spend that time on other things. Without needing to worry about the integrity of
a persistent datastore, it also means that this script can reliably be run on a
very ephemeral instance. In fact, it can be run from anywhere. Scheduled Jenkins
jobs would be a good way to run this, but with the advent of
<a href="http://docs.aws.amazon.com/lambda/latest/dg/getting-started-scheduled-events.html">Scheduled Lamdbda tasks</a>,
an Ops team can cut down even further on dependencies required to perform
maintenance tasks.</p>
</div>


<div class="meta">
	<div class="date">








  


<time datetime="2015-11-29T14:36:00-05:00" pubdate data-updated="true">Nov 29<span>th</span>, 2015</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/operations/'>operations</a>


</div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		<a class="addthis_button_facebook_like" fb:like:layout="button_count"></a>
		
		
		<a class="addthis_button_tweet"></a>
		
		
		
	</div>
	
</div>



<section id="comment">
    <h2 class="title">Comments</h2>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
</section>
</div>
	<footer id="footer" class="inner">Copyright &copy; 2015

    Chris Henry

<br /><span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</footer>
	<script src="/javascripts/slash.js"></script>


<script type="text/javascript">
      var disqus_shortname = 'thetechnician';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://chr.ishenry.com/2015/11/29/aws-tags-as-a-lightweight-datastore/';
        var disqus_url = 'http://chr.ishenry.com/2015/11/29/aws-tags-as-a-lightweight-datastore/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//go.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-6652794-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>




</body>
</html>
